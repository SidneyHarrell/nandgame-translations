{
    "missions": {
        "RELAY_NAND": {
            "title": "Non-Et",
            "splash": "<p>Bienvenue sur <b>Nandgame</b> !</p>\n <p>Vous allez construire un ordinateur à partir de composants de base.\n  <div><p>Le jeu se compose d'une série de niveaux.\n Dans chaque niveau, vous êtes chargé de construire un composant qui se comporte selon une spécification.\n Ce composant peut ensuite être utilisé comme bloc de construction dans le niveau suivant.\n\n<p>Le jeu ne nécessite aucune connaissance préalable de l'architecture informatique ou des logiciels, et ne nécessite aucune compétence en mathématiques au-delà de l'addition et de la soustraction.\n (Cela demande un peu de patience - certaines tâches peuvent prendre un certain temps à résoudre !)\n\n </div> <p>Votre première tâche est de créer un composant <b>nand</b> (Non-Et).\n <p>Sur la gauche du diagramme se trouve la spécification exacte de la tâche.\n Cliquez sur \"Aide de niveau\" pour plus d'informations qui pourraient être utiles.",
            "specification": "<p>La première tâche consiste à construire un composant <b>Nand</b> à partir de relais électriques.\n<p>Un composant Nand (NON-ET) ne produit  0 que lorsque les deux entrées (<b>a</b> et <b>b</b>) sont à 1 :</p> <table class='data'><colgroup class ='input'><col><col></colgroup><colgroup class='output'><col></colgroup><tr><th class='input' colspan='2'>Entrée</th ><th class='output' colspan='1'>Sortie</th></tr><tr><th>a</th><th>b</th><th></th></tr><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></table>\n\n<p><b>1</b> représente un courant électrique, et <b>0</b> aucun courant. <p>L'entrée <b>V</b> transporte un courant constant, c'est-à-dire toujours 1. <p>Il existe deux types de relais : l'un est activé par défaut et a besoin de courant pour s'éteindre. L'autre est éteint par défaut et a besoin de courant pour s'allumer.",
            "elaboration": "<p>Un composant <b>nand</b> (ou nand-gate) est un composant logique fondamental. En utilisant uniquement des portes nand (NON-ET), toute la logique informatique peut être construite. C'est pourquoi nous commençons par construire une porte nand !</p>\n\n<p>Un <b>relais</b> est un interrupteur à commande électrique, où un signal de commande provoque l'activation et la désactivation de l'interrupteur. Le courant de commande est connecté à un électroaimant qui déplace un contact entre les positions marche et arrêt.\n\n<p>Les premiers ordinateurs électroniques ont été construits à partir de relais électriques, mais aujourd'hui, les ordinateurs sont construits à partir de transistors. Les transistors sont des interrupteurs comme des relais, mais n'ont pas de pièces mécaniques, ce qui les rend (beaucoup) plus petits et moins chers. Nandgame utilise des relais car il est plus facile de montrer comment ils fonctionnent, mais logiquement les relais et les transistors sont similaires. Une fois que nous avons construit le composant Nand, peu importe qu'il soit implémenté à partir de relais ou de transistors.",
            "spoilers": [
                "Utilisez les relais comme deux étapes. Dans le premier relais, la sortie sera 1 lorsque a et b sont à 1. Le deuxième relais va inverser la sortie du premier, donc 1 devient 0 et 0 devient 1."
            ],
            "hints": {
                "0": "<b>Étape 1 :</b> Faites glisser les composants de la boîte à outils vers la zone bleue.\n\n",
                "1": "<b>Étape 2 :</b> Appuyez sur la flèche pour sélectionner, puis appuyez sur le connecteur source d'un composant pour créer une connexion.",
                "2": "Spécification du composant à construire. <p>Pour chaque entrée, le composant doit produire la sortie correcte.",
                "3": "Cliquez sur la case à cocher pour basculer le signal d'entrée et voir comment il affecte le circuit.",
                "4": "Cliquez ici lorsque vous pensez avoir correctement conçu le composant."
            },
            "debriefing": "Le composant <b>nand</b> (NON-ET) a maintenant été ajouté à votre boîte à outils et peut être utilisé comme élément de base dans les niveaux suivants."
        },
        "INV": {
            "title": "Inverseur",
            "splash": "<p>Votre prochaine tâche consiste à créer un composant <b>inverseur</b> à l'aide du composant <b>nand</b>.\n  <p> <p>A partir de ce niveau, nous n'avons plus besoin de considérer la mécanique des commutateurs sous-jacents. Bien qu'une porte NAND physique nécessite une connexion à une source d'alimentation, nous n'avons pas besoin de le montrer sur le schéma. Tous les composants sont considérés implicitement connectés à une source d'alimentation. Nous pouvons maintenant nous concentrer sur l'entrée/sortie logique.</p>",
            "specification": "<p>La prochaine tâche consiste à construire un composant inverseur (<b>inv</b>).\n\n  <p>Un composant <b>inv</b> a une seule entrée et une seule sortie.\n  <p>La sortie doit être l'opposé de l'entrée, donc 0 pour 1 et vice versa :",
            "hints": {
                "0": "Le composant <b>nand</b> a maintenant été ajouté à la boîte à outils."
            }
        },
        "AND": {
            "title": "Et",
            "splash": "<p>La tâche suivante consiste à construire une porte <b>et</b> en utilisant uniquement les composants <b>nand</b> et <b>inv</b>.\n  (Vous n'aurez peut-être pas besoin des deux types pour résoudre cette tâche.) ",
            "specification": "<p>La sortie d'une porte <b>et</b> est à 1 lorsque les deux entrées sont à 1 :",
            "spoilers": [
                "\"NAND\" est en fait une abréviation de \"Negative AND\" (littéralement : Non-Et)"
            ]
        },
        "OR": {
            "title": "Ou",
            "specification": "<p>La sortie de la porte <b>ou</b> est à 1 lorsqu'au moins une entrée est à 1 :"
        },
        "XOR": {
            "specification": "<p>La sortie d'une porte <b>xor</b> est à 1 lorsque les deux entrées sont différentes :",
            "title": "Xor (Non-Ou)",
            "elaboration": "XOR est l'abréviation de <i>OU exclusif</i>. Cela signifie <i>soit a, soit b mais pas les deux</i>."
        },
        "HALFADD": {
            "title": "Demi-additionneur",
            "splash": "<p>Félicitations, vous avez construit les portes logiques fondamentales.\n  <p>L'étape suivante c'est les opérations arithmétiques. Le processeur doit pouvoir additionner et soustraire des nombres.\n\n  <p>La première tâche consiste à additionner deux nombres à un bit. Le résultat sera un nombre à deux bits\n  <p>Vous devrez comprendre le système de numération binaire pour résoudre ce problème.",
            "specification": "<p>Un composant <b>add</b> qui ajoute deux bits. La sortie est une valeur à deux bits.\n  <p>La sortie <b>h</b> est le bit de poids fort, le <b>l</b> est le bit de poids faible.",
            "elaboration": "<classe div=sujet>\n\n <h3>Nombres binaires</h3>\n\n <p>Les ordinateurs effectuent l'arithmétique en utilisant le <b>système de numérotation binaire</b>.\n\n <p>En binaire, tous les nombres sont représentés en utilisant uniquement les chiffres 0 et 1. C'est différent de notre système de numérotation habituel\n qui utilise les chiffres 0-9.\n\n <p>Exemple :\n\n <classe de table=données>\n <tr><th>Binaire</th><th>Décimal</th></tr>\n <tr><td>00</td><td>0</td></tr>\n <tr><td>01</td><td>1</td></tr>\n <tr><td>10</td><td>2</td></tr>\n <tr><td>11</td><td>3</td></tr>\n </table>\n\n\n Pour comprendre le binaire, considérons le fonctionnement du système de numérotation décimale. Il y a dix chiffres distincts, mais nous pouvons exprimer de grands nombres arbitraires en utilisant la position des chiffres. Dans un nombre à trois chiffres, le premier chiffre en partant de la droite correspond aux unités, le deuxième aux dizaines, le troisième aux centaines, etc.\n Donc 273 est 2 x 100 + 7 x 10 + 3 x 1. Les positions sont des facteurs de 10.\n Le décimal est appelé un système de numérotation <i>base-10</i>.\n\n<p>Les nombres binaires sont un système de numérotation en base 2, donc seuls deux chiffres sont utilisés : 0 et 1. En binaire, les positions sont des facteurs de deux : 1, 2, 4, 8, etc.\nDonc 101 en binaire est 5 en décimal (1 x 4 + 0 x 2 + 1 x 1).\nLes nombres binaires sont idéaux pour les circuits numériques puisque les deux états des systèmes numériques peuvent être amenés à correspondre aux chiffres 0 et 1.\n\n<p><a href=\"https://www.mathsisfun.com/binary-number-system.html\">Système de numération binaire</a></p>\n\n </div>",
            "spoilers": [
                "Regardez les deux colonnes de sortie séparément et voyez si vous reconnaissez un motif."
            ]
        },
        "FULLADD": {
            "title": "Additionneur complet",
            "splash": "<p>Vous avez maintenant construit un additionneur qui peut additionner deux bits.\n  <p>Mais pour ajouter des nombres plus importants, nous devons également prendre en compte une \"retenue\" d'une addition précédente.\n  <p>Cette mission consiste à construire un composant additionneur qui ajoute les <i>trois</i> bits a et b et c, où c est un bit de retenue.",
            "specification": "<p>Un composant <b>add</b> qui ajoute trois bits : <b>a</b>, <b>b</b> et <b>c</b>.\n  <p>La sortie est une valeur à deux bits. La sortie <b>h</b> est le bit de poids fort, le <b>l</b> est le bit de poids faible.",
            "elaboration": "Le but est de pouvoir additionner des nombres arbitrairement grands. Nous ajoutons donc la première paire de chiffres, puis nous prenons la retenue (le cas échéant) et ajoutons la paire de chiffres suivante."
        },
        "ADD2": {
            "title": "Additionneur multi-bits",
            "splash": "<p>Construisez maintenant un additionneur qui additionne deux nombres de 2 bits (et  1 bit de retenue).\n  <p>Les additionneurs 2 bits peuvent être répétés pour que les additionneurs fonctionnent sur de plus grands nombres.",
            "specification": "<p>Créez un additionneur qui additionne deux nombres de 2 bits et une retenue de 1 bit.\n  <h3>Entrée</h3>\n  <p><b>a1 a0</b> est un nombre de 2 bits.\n  <p><b>b1 b0</b> est un nombre de 2 bits.\n  <p><b>c</b> (retenue d'entrée) est un nombre de 1 bit.\n  <h3>Sortie</h3>\n  <p>La somme des nombres d'entrée sous la forme du nombre à 3 bits <b>c s1 s0</b> où <b>c</b> est le bit de poids fort.\n\n  <h3>Exemple</h3>\n\n  <table class='data'>\n  <colgroup class=input><col><col></colgroup>\n  <colgroup class=input><col><col></colgroup>\n  <colgroup class=input><col></colgroup>\n  <colgroup class=output><col><col><col></colgroup>\n  <colgroup class=output><col></colgroup>\n  <tr><th colspan=5>Entrée</th><th colspan=3>Sortie</th></tr>\n  <tr><th>a1</th><th>a0</th><th>b1</th><th>b0</th><th>c</th><th>c</th ><th>s1</th><th>s0</th></tr>\n  <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td ><td>0</td><td>1</td><td>2+2+1=5</td></tr>\n  </table>",
            "debriefing": "<p>La conception du composant pour ajouter des nombres binaires à deux chiffres peut être répétée pour additionner de grands nombres arbitraires.\n\n  <p>Puisque nous construisons un processeur 16 bits, nous répétons ce composant pour créer un composant additionneur 16 bits et l'ajouter à votre boîte à outils avec le nom <b>add 16</b>."
        },
        "INC": {
            "title": "Increment",
            "splash": "<p>Vous êtes maintenant prêt à commencer à travailler avec des nombres 16 bits.\n\n  <p>Votre mission est de construire un composant <b>incrément</b> qui ajoute 1 à un nombre de 16 bits.\n\n  <p>Comme vous travaillez maintenant avec des nombres à 16 bits, nous avons simplifié\nla représentation sur le schéma : Au lieu de 16 fils et connecteurs séparés,\nils sont regroupés et présentés comme un seul connecteur, indiqué par une petite étiquette \"<b>16</b>\".",
            "specification": "<p>Ajouter <b>1</b> à un nombre 16 bits.<p>\n  <p>Ignorer la retenue si le résultat est supérieur à 16 bits",
            "hints": {
                "0": "Sortie 16 bits comme unité. Affiche la sortie en hexadécimal et en décimal signé.",
                "1": "Entrée 16 bits en tant qu'unité. Vous pouvez entrer la valeur sous forme hexadécimale ou décimale."
            },
            "elaboration": "<p><b>Incrémenter</b> signifie augmenter un nombre de 1. Ceci est utile dans de nombreux endroits, par exemple dans les compteurs.\n\n\n <h3>16 bits</h3>\n\n <p>Un processeur fonctionne toujours sur plusieurs bits à la fois.\n Le processeur que vous construisez est un <b>processeur 16 bits</b>, ce qui signifie qu'il fonctionne sur des ensembles de 16 bits à la fois.\n\n <p>Les processeurs modernes (tels que ceux d'un ordinateur ou d'un smartphone) sont généralement 32 bits ou 64 bits. Les processeurs intégrés tels que ceux d'un four à micro-ondes peuvent être 8 bits ou 4 bits.\n Nous avons choisi 16 bits car c'est suffisant pour être utile.\n\n <h3>Mots et octets</h3>\n <p>Un ensemble de 16 bits est appelé un <b>mot</b>. La taille d'un mot dépend du processeur.\n Un <b>octet</b> est une unité indépendante de la machine qui est toujours de 8 bits.\n\n <div>\n <h3>Bus</h3>\n <p>Un ensemble de connexions traitées comme une unité est appelé un <b>bus</b>. L'entrée et la sortie sont chacune un bus 16 bits.\n Les entrées <b>A</b> et <b>B</b> sur l'additionneur 16 bits sont également chacune un bus 16 bits.\n </div>\n\n <div>\n <h3>Hexadécimal</h3>\n <p>Les grands nombres binaires sont difficiles à lire et à taper pour les humains. Nous avons donc des nombres <b>hexadécimaux</b> qui sont plus courts et plus faciles à gérer.\n L'hexadécimal est un système de numérotation en base 16, où les lettres A, B, C, D, E, F sont utilisées pour les nombres dix à quinze.\n <p>L'hexadécimal (abrégé <i>hex</i>) est pratique pour les données binaires puisqu'un chiffre hexadécimal correspond toujours à quatre bits. Un mot de 16 bits est composé de quatre chiffres hexadécimaux. Les chiffres décimaux ne correspondent pas directement aux chiffres binaires, donc la décimale est moins pratique pour les données binaires.\n\n <p>Exemples :\n <table class='nombres donnés'>\n <tr><th>hex</th><th>décimal non signé</th><th>binaire</th></tr>\n <tr><td>1</td><td>1</td><td>0000000000000001</td></tr>\n <tr><td>F</td><td>15</td><td>0000000000001111</td></tr>\n <tr><td>10</td><td>16</td><td>0000000000010000</td></tr>\n <tr><td>2A</td><td>42</td><td>0000000000101010</td></tr>\n <tr><td>0100</td><td>256</td><td>0000000100000000</td></tr>\n <tr><td>FFFF</td><td>65535</td><td>1111111111111111</td></tr>\n </table>\n\n <p>Pour votre commodité, les ports d'entrée et de sortie 16 bits affichent les nombres en hexadécimal à côté du binaire. Vous pouvez entrer des nombres hexadécimaux,\n et ils seront automatiquement convertis en binaire.\n\n <p>Un <a href=\"https://www.mathsisfun.com/hexadecimals.html\">tutoriel hexadécimal</a>. [Si vous trouvez un meilleur tutoriel que celui-ci, veuillez m'envoyer le lien]\n\n </div>",
            "spoilers": [
                "Un connecteur d'entrée n'a pas besoin d'être connecté à quoi que ce soit. Une entrée non connectée est toujours 0.",
                "Une porte <b>inv</b> qui n'est connectée à aucune entrée sortira toujours 1",
                "L'entrée de retenue <b>c</b> sur <b>add</b> est une entrée à 1 bit et accepte un 0 ou un 1 binaire."
            ]
        },
        "SUB": {
            "title": "Soustraction",
            "splash": "<p>Construisez maintenant un composant qui <b>soustrait</b> un nombre 16 bits à un  autre.",
            "specification": "<p>Sortie A moins B sous la forme d'un nombre de 16 bits.\n  <p>Si le résultat est inférieur à zéro, il est représenté par 65536 plus le résultat.\n  <p>Exemples :\n\n  <table class='numéros de données'>\n  <tr><th>résultat</th><th>binaire 16 bits</th><th>décimal non signé</th></tr>\n  <tr><td>1</td><td>0000000000000001</td><td>1</td></tr>\n  <tr><td>0</td><td>0000000000000000</td><td>0</td></tr>\n  <tr><td>-1</td><td>1111111111111111</td><td>65535</td></tr>\n  <tr><td>-2</td><td>1111111111111110</td><td>65534</td></tr>\n  <tr><td>-3</td><td>1111111111111101</td><td>65533</td></tr>\n  </table>\n\n  <p>(Ceci est équivalent à la représentation en complément à deux)",
            "elaboration": "<classe div=sujet>\n\n <h3>Complément à deux</h3>\n <p>Le complément à deux est la manière standard de représenter les nombres signés (positifs et négatifs) en binaire.\n <p>Le bit 15 est considéré comme le signe.\n Si le bit 15 est 0, le nombre est positif ; si 1, le nombre est négatif. Les nombres négatifs ont la même valeur que 65536 moins le nombre.\n Par exemple -127 correspond au nombre non signé 65409 car 65536 - 127 = 65409\n\n <p>Quelques exemples :\n <table class='numéros de données'>\n <tr><th>Décimal signé</th><th>Décimal non signé</th><th>Binaire 16 bits</th><th>Hex</th></tr>\n <tr><td>32767</td><td>32767</td><td>0111111111111111</td><td>7FFF</td></tr>\n <tr><td>1</td><td>1</td><td>0000000000000001</td><td>0001</td></tr>\n <tr><td>0</td><td>0</td><td>0000000000000000</td><td>0000</td></tr>\n <tr><td>-1</td><td>65535</td><td>111111111111111</td><td>FFFF</td></tr>\n <tr><td>-2</td><td>65534</td><td>111111111111110</td><td>FFFE</td></tr>\n <tr><td>-3</td><td>65533</td><td>111111111111101</td><td>FFFD</td></tr>\n <tr><td>-32768</td><td>32768</td><td>1000000000000000</td><td>8000</td></tr>\n </table>\n\n <p>\n </div>",
            "spoilers": [
                "Étudier comment une inversion binaire (<b>inv16</b>) affecte un nombre",
                "Une inversion d'un nombre est égale à 65535 moins le nombre. Un nombre négatif est 65536 moins le nombre.",
                "A - B = A + INV(B) + 1"
            ],
            "debriefing": "Félicitations, vous avez construit des composants pour les opérations arithmétiques fondamentales.\n  <p>Les processeurs modernes prennent en charge une arithmétique beaucoup plus complexe, comme la multiplication, la division et les nombres à virgule flottante,\n  mais dans ce jeu, nous gardons les choses simples et créons le strict minimum nécessaire pour un processeur fonctionnel."
        },
        "ISZERO": {
            "title": "Égal à zéro",
            "splash": "<p>Construisez maintenant un composant qui indique si un nombre est égal à zéro. Nous l'implémentons d'abord pour un nombre de quatre bits.",
            "specification": "<p> Devrait sortir 1 si et seulement si tous les bits de l'entrée sont 0.",
            "debriefing": "Cette approche peut trivialement être étendue à 16 bits, nous avons donc un composant qui vérifie si un nombre de 16 bits est égal à zéro."
        },
        "SIGN": {
            "title": "Moins que zéro",
            "splash": "<p>Concevez maintenant un composant qui indique si un nombre 16 bits est négatif.",
            "specification": "<p>La sortie est a 1 si l'entrée sous forme d'unnombre à 16 bits est négative\n\n  <p>Spécification :\n  <table class='data'>\n  <colgroup class=input><col></colgroup>\n  <colgroup class=output><col></colgroup>\n  <tr><th>Entrée</th><th>Sortie</th></tr>\n  <tr><td>entrée >= 0</td><td>0</td></tr>\n  <tr><td>entrée &lt; 0</td><td>1</td></tr>\n  </table>\n\n  Un nombre est considéré comme inférieur à zéro si le bit 15 est à 1.\n<h3>Numérotation des bits</h3>\nLes bits sont numérotés de droite à gauche, en commençant par 0 comme bit le plus à droite. Le bit 15 est donc le bit le plus à gauche dans un mot de 16 bits.",
            "elaboration": "Pour les besoins de ce composant, nous interprétons la valeur 16 bits comme un entier signé et le bit le plus à gauche comme le signe.\n\n <p>Nous avons ajouté un <b>séparateur</b> à la boîte à outils. Le séparateur divise un bus 16 bits en 16 connecteurs individuels.\n À l'aide du séparateur, vous pouvez examiner les bits individuels d'une entrée 16 bits. Le répartiteur n'a pas de logique interne.\n\n <classe div=sujet>\n <h3>Numéros signés et non signés</h3>\n\n <p>La même valeur 16 bits peut être interprétée comme un entier signé ou non signé. Exemples pour certains nombres autour de 0 :\n\n <table class='numéros de données'>\n <tr><th>Binaire 16 bits</th><th>Hexadécimal</th><th>Décimal non signé</th><th>Décimal signé</th></tr>\n <tr><td>0000000000000001</td><td>0001</td><td>1</td><td>1</td></tr>\n <tr><td>0000000000000000</td><td>0000</td><td>0</td><td>0</td></tr>\n <tr><td>1111111111111111</td><td>FFFF</td><td>65535</td><td>-1</td></tr>\n <tr><td>1111111111111110</td><td>FFFE</td><td>65534</td><td>-2</td></tr>\n <tr><td>1111111111111101</td><td>FFFD</td><td>65533</td><td>-3</td></tr>\n </table>\n\n <p>De manière pratique, l'addition et la soustraction fonctionnent exactement de la même manière, que nous interprétions les nombres comme signés ou non signés.\n Cela signifie que le processeur n'a pas vraiment besoin de connaître la différence.\n\n [TODO : lien vers le tutoriel sur le complément à deux]\n </div>",
            "spoilers": [
                "Vous n'avez besoin d'aucun des composants logiques, juste du séparateur."
            ]
        },
        "MULTIPLEXER": {
            "title": "Sélecteur",
            "specification": "<p>Un composant <b>select</b> sélectionne l'un des bits d'entrée parmi 2 pour le relier à la sortie.\n\n  <p>Le bit <b>s</b> (select) indique quelle entrée est sélectionnée :\n  Si 0, <b>d0</b> est sélectionné, si 1, <b>d1</b> est sélectionné.",
            "elaboration": "<p>Ce composant est également appelé <b>multiplexeur</b>."
        },
        "DEMUX": {
            "splash": "Ensuite, construisez un <b>commutateur</b> qui relie un bit de donnée à 1 des 2 canaux de sortie.",
            "title": "Commutateur",
            "specification": "<p>Un composant <b>commutateur</b> relie un bit de données via l'un des deux canaux de sortie.\n\n  <p><b>s</b> (sélecteur) détermine si le bit <b>d</b> (données) est distribué\n  via <b>c1</b> ou <b>c0</b>."
        },
        "SR_LATCH": {
            "splash": "<p>Les composants construits jusqu'à présent n'ont pas de mémoire.\n\n  <p>Votre mission cette fois est de construire une <b>bascule latch</b> (littéralement, bascule verrou), un composant qui peut stocker un bit."
        },
        "LATCH": {
            "specification": "<p>Un composant <b>bascule</b> stocke et génère un seul bit\n  <p>Lorsque <b>st</b> (stocker) est 1, la valeur sur <b>d</b> est stockée et émise.\n  <p>Lorsque <b>st</b> vaut 0, la valeur de <b>d</b> est ignorée et la valeur précédemment stockée est toujours émise.\n\n  <p>Pour décrire cela dans un tableau d'entrées/sorties, nous introduisons une variable, <b>out</b>, à laquelle on peut attribuer une valeur de bit et la conserver :</p>\n\n  <table class='data'>\n  <colgroup class=input><col><col></colgroup>\n  <colgroup class=input><col></colgroup>\n  <colgroup class=output><col></colgroup>\n  <tr><th colspan=2>Entrée</th><th>Effet</th><th>Sortie</th></tr>\n  <tr><th>er</th><th>d</th><th></th><th></th></tr>\n  <tr><td>1</td><td>0</td><td>fixe <b>out</b> à 0</td><td><b>out</b></td></tr>\n  <tr><td>1</td><td>1</td><td>mis <b>hors</b> à 1</td><td><b>hors</b></td></tr>\n  <tr><td>0</td><td>1</td><td>-</td><td><b>sortie</b></td></tr>\n  <tr><td>0</td><td>0</td><td>-</td><td><b>sortie</b></td></tr>\n  </table>",
            "title": "Bascule Latch"
        },
        "DFF": {
            "title": "Bascule Flip-Flop",
            "splash": "<p>À l'aide de bascules latch, vous pouvez construire un circuit qui change d'état au fil du temps.\n  <p>Mais un problème apparaît alors : puisque les changements d'état ne sont pas synchronisés à travers le circuit,\n  les changements se répercutent sur le circuit dans un ordre imprévisible, entraînant des 'race conditions' et des résultats généralement imprévisibles.\n\n  <p>La solution est un <b>signal d'horloge</b>, une valeur de bit qui\n  change automatiquement et qui est connecté à tous les composants avec état.\n\n  <p> Si les composants ne changent de sortie que lorsque le signal d'horloge change, alors les changements se produiront sur le circuit en même temps\n  et nous évitons les problèmes de synchronisation.\n\n  <p>Dans cette tâche, vous allez créer un composant <b>flip-flop</b> qui stocke un\n  bit lorsque le signal d'horloge est 0 mais ne commence à émettre le bit stocké que lorsque le signal d'horloge passe à 1.",
            "specification": "<p>Un composant <b>DFF</b> (Data Flip-Flop) stocke et emet un bit, mais ne change sa sortie que lorsque le signal d'horloge passe de 0 à 1.\n\n <p>Lorsque <b>st</b> (stocker) est 1 et <b>cl</b> (signal d'horloge) est 0, la valeur sur <b>d</b> est stockée.\n Mais la valeur précédente est toujours émise.\n <p>Lorsque le signal d'horloge passe à 1, la bascule commence à émettre la nouvelle valeur.\n \n <p>Lorsque <b>st</b> vaut 0, la valeur de <b>d</b> n'a aucun effet.\n <p>Lorsque <b>cl</b> vaut 1, la valeur de <b>st</b> et <b>d</b> n'a aucun effet.\n\n <p>Pour décrire cela dans un tableau il nous faut 2 variables, <b>in</b> et <b>out</b> :\n\n<table class=\"données\">\n <colgroup class=input><col><col><col></colgroup>\n <colgroup class=input><col></colgroup>\n <colgroup class=output><col></colgroup>\n<tr><th colspan=3>Entrée</th><th>Effet</th><th>Sortie</th></tr>\n<tr><th>st</th><th>d</th><th>cl</th><th></th><th></th></tr>\n<tr><td>1</td><td>0</td><td>0</td><td>mettre <b>dans</b> à 0</td><td><b >sortie</b></td></tr>\n<tr><td>1</td><td>1</td><td>0</td><td>définir <b>in</b> sur 1</td><td><b >sortie</b></td></tr>\n<tr><td>0</td><td>-</td><td>0</td><td>-</td><td><b>sortie</b></td> </tr>\n<tr><td>-</td><td>-</td><td>1</td><td>mettre <b>dehors</b> à <b>dedans</b></td><td><b>sortie</b></td></tr>\n</table>",
            "elaboration": "<p>Le signal d'horloge est comme un métronome, faisant changer tous les composants à l'unisson.\n\n<p>Un <b>cycle d'horloge</b> est la durée du signal d'horloge passant de 0 à 1, puis de 1 à 0.\n\n<p>Dans un vrai processeur, le signal d'horloge est déclenché par une sorte de cristal vibrant. Dans ce jeu, nous gardons le signal d'horloge comme entrée manuelle,\nafin que vous puissiez tester manuellement le circuit.\n\n<p>La <b>fréquence d'horloge</b> correspond à la vitesse à laquelle l'horloge change. Plus la fréquence d'horloge est élevée, plus l'ordinateur fonctionne rapidement.\n\n<p>Remarque : malgré son nom, une \"horloge\" ne garde pas l'heure en elle-même. Il ne fournit qu'un battement régulier.\nMais combiné avec un compteur, un composant qui garde une trace du temps peut être construit.",
            "spoilers": [
                "Vous devez utiliser deux bascules latch.",
                "Un verrou doit être écrit lorsque cl=0, le verrou suivant doit être écrit à partir du premier verrou lorsque cl=1."
            ]
        },
        "DFF2": {
            "splash": "<p>Vous pouvez maintenant stocker un seul bit de données.\n  <p>Dans cette mission, vous devez combiner deux bascules de données (DFF) pour stocker et récupérer <b>deux</b> bits de données en une seule opération.\n  <p>(En fin de compte, nous voulons stocker et récupérer des mots de 16 bits à la fois, mais si vous savez comment stocker deux bits, stocker des ensembles plus grands est trivial.)",
            "specification": "<p>Un composant <b>2-bit DFF</b> fonctionne comme une bascule de données,\n  sauf que deux bits (<b>d1</b> et <b>d0</b>) sont stockés et émis au lieu d'un.",
            "elaboration": "La conception d'un stockage à deux bits peut être trivialement répétée.\n  Nous le répétons pour obtenir une unité de stockage 16 bits. Nous appelons ce composant un <b>registre</b>.",
            "title": "Registre",
            "debriefing": "La conception d'une unité de stockage 2 bits pourrait facilement être répétée pour générer une unité 8, 16 ou 32 bits.\n  <p>Puisque vous construisez un ordinateur 16 bits, une unité de stockage 16 bits (appelée <b>registre</b>) a été générée et ajoutée à votre boîte à outils."
        },
        "COUNTER": {
            "splash": "<p>La tâche suivante consiste à construire un compteur qui incrémente un nombre à chaque cycle d'horloge.\n  <p>Les compteurs sont un composant central d'un processeur car ils pilotent l'exécution des instructions.",
            "title": "Compteur",
            "specification": "<p>Un composant <b>compteur</b> incrémente un nombre pour chaque cycle d'horloge.\n\n  <p>La sortie du compteur change lorsque <b>cl</b> (signal d'horloge) passe à 1.\n  <p>Si <b>st</b> vaut 0, alors la valeur de compteur précédente est incrémentée de 1.\n  <p>Si <b>st</b> (stocker) est 1, alors la valeur d'entrée <b>X</b> est utilisée comme nouvelle valeur de compteur.\n\n<p>Décrire cela dans un tableau nécessite deux variables, <b>in</b> et <b>out</b>, qui stockent des nombres 16 bits :\n\n<table class=\"données\">\n  <colgroup class=input><col><col></colgroup>\n  <colgroup class=input><col></colgroup>\n  <colgroup class=output><col></colgroup>\n<tr><th colspan=2>Entrée</th><th>Effet</th><th>Sortie</th></tr>\n<tr><th>er</th><th>cl</th><th></th><th></th></tr>\n<tr><td>0</td><td>0</td><td class=text>définissez <b>in</b> sur <b>out</b> + 1</td><td><b>sortie</b></td></tr>\n<tr><td>1</td><td>0</td><td class=text>définir <b>dans</b> sur <b>X</b></td><td> <b>sortie</b></td></tr>\n<tr><td>-</td><td>1</td><td class=text>mettre <b>dehors</b> à <b>dedans</b></td><td> <b>sortie</b></td></tr>\n</table>",
            "spoilers": [
                "Vous avez besoin d'un seul composant registre."
            ]
        },
        "RAM": {
            "title": "RAM",
            "splash": "<p>Vous pouvez maintenant stocker un mot de 16 bits dans un registre.\n  <p>Nous pouvons obtenir plus de mémoire simplement en empilant ces registres.\n  <p>Mais puisqu'un processeur opère sur un mot à la fois, nous avons besoin d'un moyen de\n  sélectionner et modifier des mots individuels dans une plus grande banque de mémoire.\n  <p>Nous utilisons des adresses mémoire pour cela.\n  <p>Nous attribuons à chaque mot en mémoire un numéro\n  afin que nous puissions récupérer ou écraser un mot en utilisant ce numéro.\n\n  <p>Dans cette mission, vous devez utiliser deux registres et les adresser en utilisant un seul bit.",
            "specification": "<p>Construisez une unité de mémoire avec deux registres 16 bits adressables et inscriptibles à l'aide d'une adresse d'un bit.\n  <h3>Entrée</h3>\n  <p><b>ad</b> (adresse) indique à quelle unité de stockage nous accédons.\n  <p><b>st</b> (store) indique si nous voulons écrire dans l'unité.\n  <ul>\n  <li>Si 1, la valeur sur <b>X</b> est stockée dans l'unité.\n  <li>Si 0, alors <b>X</b> est ignoré.\n  </ul>\n  <p><b>X</b> (données) est une valeur de 16 bits.\n  <p><b>cl</b> (signal d'horloge) synchronise les changements d'état. <b>X</b> est stocké lorsque <b>cl</b>=0, mais émis uniquement lorsque <b>cl</b> passe à 1.\n  <h3>Sortie</h3>\n  <p>La valeur actuellement stockée dans l'unité adressée par <b>ad</b>.",
            "elaboration": "<p>Une mémoire de la taille de deux mots n'est pas grand chôse. Mais si nous pouvons faire fonctionner cela, nous pouvons répéter cette conception de manière récursive pour obtenir 4, 8, 16, etc.\n\n <h3>Adressage</h3>\n <p>Nous numérotons les mots de données en mémoire en partant de 0. Le numéro d'un mot mémoire est appelé son <b>adresse</b>.\n Lors de la lecture ou de l'écriture d'une cellule mémoire, nous utilisons son adresse pour y accéder.\n\n <p>Avoir deux cellules signifie que nous n'avons que deux adresses qui peuvent être sélectionnées par un seul bit. Comme nous avons une architecture 16 bits, nous pouvons prendre en charge jusqu'à 16 bits d'adresses,\n ce qui implique que nous pouvons adresser 65 536 mots de données.\n\n <p>Ce type de mémoire est appelé RAM (Random Access Memory) car nous pouvons accéder à n'importe quelle cellule et mettre à jour sa valeur tant que nous connaissons son adresse.\n\n <classe div=sujet>\n <h3>Octets et Ko</h3>\n <p>La capacité de mémoire (RAM et autre stockage) est mesurée en <b>octets</b>, où un octet correspond à 8 bits.\n Parce que nous avons une architecture 16 bits, nous stockons et récupérons des mots de 16 bits à la fois, chaque mot est de 2 octets.\n On peut avoir 65536 cellules mémoire (puisque 65535 est le nombre le plus élevé pouvant être exprimé en 16 bits), donc mesuré\n en octets, nous avons le double du nombre, 131 072 octets. Ceci est généralement écrit comme 128 Ko (Ko = kilo-octets).\n\n <p>Comment 131 072 devient-il 128 000 ? Cela est dû au fait merveilleux que lors de la mesure des octets, K ne signifie pas 1000\n (comme pour les autres mesures) mais 1024. Et 128*1024 = 131 072.\n\n </div>",
            "debriefing": "<p>Cette conception pour une RAM adressable 2 bits peut être répétée de manière récursive pour créer des unités de RAM plus grandes."
        },
        "ALU_PRESET": {
            "splash": "<p>Les composants construits jusqu'à présent ont tous effectué une seule opération spécifique.\n  <p>Une ALU (unité arithmétique et logique) est un composant de base qui peut effectuer\n  un ensemble d'opérations logiques et arithmétiques différentes telles que l'addition, la soustraction et l'inversion.\n  <p>Un ensemble de bits de contrôle détermine l'opération à effectuer.\n  <p>L'ALU est implémentée en deux étapes.\n  La première étape est une \"ALU unaire\" qui inverse une entrée ou la remplace par zéro.",
            "title": "ALU unaire",
            "specification": "<p>Une <b>ALU unaire</b> modifie une seule entrée <b>X</b>. Deux drapeaux sélectionnent les opérations à appliquer.\n\n<p>Si <b>z</b> (zéro) est 1, alors 0 est sorti au lieu de l'entrée\n<p>Si <b>n</b> (négation) est 1, alors l'entrée est inversée\n<p>L'ordre est significatif, donc si les deux sont 1, la sortie sera l'inversion de 0.\n\n<p>Spécification :\n  <table class='data'>\n  <colgroup class=input><col><col></colgroup>\n  <colgroup class=output><col></colgroup>\n  <tr><th colspan=2>Entrée</th><th>Sortie</th></tr>\n  <tr><th>z</th><th>n</th><th></th><th></th></tr>\n  <tr><td>0</td><td>0</td><td>X non modifié</td></tr>\n  <tr><td>1</td><td>0</td><td>0</td></tr>\n  <tr><td>0</td><td>1</td><td>Inverser X</td></tr>\n  <tr><td>1</td><td>1</td><td>Inverser 0</td></tr>\n  </table>",
            "elaboration": "<h3>Conception de l'unité logique arithmétique (ALU)</h3>\n\n<p>L'ALU est un composant qui peut effectuer diverses opérations arithmétiques et logiques différentes.\nIl y a deux entrées, X et Y, et un ensemble d'options (flags) qui sélectionne l'opération à effectuer sur les entrées.\n\n<p>Certaines des opérations qu'il peut effectuer sont l'addition (X+Y), la soustraction (X-Y ou Y-X), le ET logique (X et Y), le OU logique (X ou Y). Il peut également effectuer des opérations sur une seule entrée (et ignorer l'autre) ; par exemple, incrémenter (X+1), décrémenter (X-1), inverser X et annuler X (0-X).\n\n<p>Il semblerait que nous ayons besoin d'un composant très complexe pour prendre en charge toutes ces opérations. Mais il s'avère que nous pouvons les atteindre en combinant seulement deux opérations avec deux modifications possibles de chaque entrée et sortie.\n\n<p>Par exemple, nous avons vu au niveau \"soustraction\" que la soustraction peut être implémentée en termes d'addition si nous pouvons inverser une entrée et une sortie.\nEt nous avons vu au niveau \"incrémentation\" que l'incrémentation (ajout de 1 à X) peut être implémentée en remplaçant Y par 0 puis en inversant et en soustrayant.\n<p>Juste en inversant et/ou en mettant à zéro l'une des deux entrées et peut-être la sortie, nous pouvons implémenter tout un tas d'opérations arithmétiques.\n\n<p>Nous mettons donc en œuvre l'ALU en deux étapes. Tout d'abord, nous construisons le composant unaire qui peut inverser et/ou mettre à zéro une entrée. (\"unaire\" signifie qu'il fonctionne sur un seul numéro)\nEt dans l'étape suivante, nous combinons les modificateurs d'entrée/sortie avec les opérations binaires pour compléter l'ALU."
        },
        "ALU": {
            "title": "ALU",
            "splash": "<p>Nous pouvons maintenant construire l'ALU elle-même.\n  <p>Il existe deux valeurs d'entrée 16 bits et six options individuelles qui déterminent les opérations à effectuer sur l'entrée.",
            "specification": "<p>L'ALU (unité arithmétique/logique) effectue une ou plusieurs opérations sur deux valeurs d'entrée\n  <b>X</b> et <b>Y</b>.\n\n  <p>Les six flags sélectionnent les opérations à effectuer.\n  Chaque indicateur déclenche une opération lorsque l'indicateur est 1 :\n\n  <table><tr><th>zx</th><td>Utiliser 0 pour X</td></tr><tr><th>nx</th><td>Inverser X</td></tr><tr><th>zy</th><td>Utiliser 0 pour Y</td></tr><tr><th>ny</th><td>Inverser Y</td></tr><tr><th>f</th><td>sélectionne une opération :\n  <br />0 : la sortie est X ET Y\n  <br />1 : la sortie est X + Y</td></tr><tr><th>non</th><td>Inverser la sortie</td></tr></table>\n\n\n  <p>Les flags peuvent être combinés et l'ordre spécifié est significatif.\n  <p>Par exemple, si <b>zx</b> et <b>nx</b> sont 1,\n  alors X est 0 inversé.",
            "elaboration": "<p>En combinant les six drapeaux, vous pouvez effectuer un large éventail d'opérations arithmétiques.\n <p>Quelques exemples :\n <table class='numéros de données'>\n <tr><th>zx</th><th>nx</th><th>zy</th><th>ny</th><th>f</th><th>non</th ><th>résultat</th></tr>\n <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td ><td>X + Y</td></tr>\n <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td ><td>X - 1</td></tr>\n <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td ><td>X et Y</td></tr>\n <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td ><td>X - Y</td></tr>\n <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td ><td>0</td></tr>\n <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td ><td>1</td></tr>\n </table>\n\n <p>Il n'est peut-être pas immédiatement évident de savoir pourquoi une certaine combinaison d'indicateurs provoque un certain résultat, mais vous pouvez les essayer vous-même pour voir comment cela fonctionne.\n\n\n <p>(La conception ALU est basée sur le <a href=\"https://www.nand2tetris.org/\">cours Nand to Tetris</a> et est utilisée ici avec autorisation.)"
        },
        "OPCODES1": {
            "title": "Opcodes",
            "specification": "<p>Sélectionnez la combinaison de bit-flags pour l'ALU qui correspondent à l'expression de l'opcode.</p><p>La plupart des expressions sont explicites.</p><p><b>~</ b> est une inversion binaire : inverser tous les bits de l'entrée</p><p><b>&</b> est un <b>et</b><p>binaire. <b>|</b> est un <b>ou</b><p> binaire. Remarque : Certaines entrées peuvent avoir plusieurs solutions valides.",
            "spoilers": [
                "Rappelez-vous du niveau de soustraction, l'inversion au niveau du bit d'un nombre est égale au négatif plus un. ~X = -X-1",
                "Ainsi, le flag <b>nx</b> donne -X-1 et le flag <b>ny</b> donne -Y-1"
            ],
            "elaboration": "Ce niveau montre comment une variété d'opérations logiques et arithmétiques peuvent être effectuées simplement par différentes combinaisons d'indicateurs de bits. Il montre également le but des <b>opcodes</b> qui sont des représentations textuelles ou symboliques des jeux de bits correspondants. Les opcodes sont beaucoup plus faciles à lire et à comprendre pour les humains que les ensembles de bits bruts ou les nombres binaires.</p>\n\n<p>Ainsi, les programmes sont généralement écrits à l'aide d'opcodes, qui sont ensuite traduits en nombres binaires par un outil.</p>"
        },
        "CONDITION": {
            "title": "Condition",
            "specification": "<p>Les trois flags indiquent trois conditions possibles pour le nombre <b>X</b> :\n\n <table class='texte de données'>\n <tr><th>Signaler</th><th>Condition</th>\n <tr><td><b>lt</b></td><td>Moins de zéro</td>\n <tr><td><b>eq</b></td><td>Égal à zéro</td>\n <tr><td><b>gt</b></td><td>Supérieur à zéro</td>\n </table>\n\n <p>Si le flag pour la la bonne condition est 1, alors la sortie est 1.\n\n\n <p>Les drapeaux peuvent être combinés ainsi :\n\n <table class='data'>\n <tr><th colspan=3>Drapeaux</th> <th>Sortie 1 lorsque</th></tr>\n <tr><th>lt</th><th>eq</th><th>gt</th><th></th></tr>\n <tr><td>0</td><td>0</td><td>0</td> <td>Jamais</td></tr>\n <tr><td>0</td><td>0</td><td>1</td> <td>X &gt ; 0</td></tr>\n <tr><td>0</td><td>1</td><td>0</td> <td>X = 0</td></tr>\n <tr><td>0</td><td>1</td><td>1</td> <td>X ≥ 0</td></tr>\n <tr><td>1</td><td>0</td><td>0</td> <td>X &lt; 0</td></tr>\n <tr><td>1</td><td>0</td><td>1</td> <td>X ≠ 0</td></tr>\n <tr><td>1</td><td>1</td><td>0</td> <td>X ≤ 0</td></tr>\n <tr><td>1</td><td>1</td><td>1</td> <td>Toujours</td></tr>\n </table>",
            "spoilers": [
                "Une seule des trois conditions peut être vraie à la fois.",
                "Il existe déjà des composants disponibles pour déterminer les deux premières conditions.",
                "\"X ≤ 0\" signifie que X est : inférieur à 0 <i>ou</i> égal à zéro.",
                "La sortie est 1 si <b>lt</b>=1 et X<0 ou <b>eq</b>=1 et X=0 ou <b>gt</b>=1 et X>0."
            ]
        }
    }
}
