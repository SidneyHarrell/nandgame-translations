{
    "missions": {
        "RELAY_NAND": {
            "hints": {
                "drag": "<b>Шаг 1:</b> Перетащите элемент с панели инструментов (toolbox) на синее поле.",
                "tap": "<b>Шаг 2:</b> Нажмите на трегольник под элементом, выделятся сигналы которые можно подключить к этому входу. Выберите нужный кликнув по нему.",
                "truth": "Описание элемента. <p>Элемент должен вырабатывать правильный выходной сигнал (output) для каждого входного сигнала (input).",
                "toggle": "Кликните по чекбоксу, чтобы изменить входной сигнал и увидеть, как это повлияет на работу вашей схемы.",
                "verify": "аконец нажмите эту кнопку, когда вы уверены, что собрали элемент правильно, и проверьте себя."
            }
        },
        "INV": {
            "title": "НЕ",
            "splash": "<p>Добро пожаловать в <b>The Nand Game</b>!</p>\n        <p>Вы собираетесь построить простой компьютер.\n        <p>Начнем с элемента <b>И-НЕ</b> (NAND).\n        Используя его как базовый блок, вы соберете все остальные необходимые элементы.\n\n        <p>Ваша первая задача собрать инвертор - элемент отрицания <b>НЕ</b>.\n        <p>В колонке слева содержится необходимая информация для выполнения этого задания.\n        Ниже приведено подробное разъяснение, которое может быть весьма полезно.\n        (прим. пер. Так как игра по-прежнему  дорабатывается. Описание может быть во вкладке Level Help, а не снизу)",
            "specification": "<p>Первое задание - собрать элемент <b>НЕ</b>.\n\n        <p><b>Инвертор</b> имеет один вход и один выход.\n        <p>Выход должен быть противоположен входу, так 1 должна превращаться в 0 и наоборот.\n\n        <p>Элементы обычно описываются таблицой, показывающей связь между входом и выходом, например такой::",
            "elaboration": "<h3>Introduction</h3>\n        <p>The Nand Game takes you though building a working computer, starting from the most basic components.\n        It does not require any prerequisites, in particular it does not require any previous knowledge about computer architecture or software,\n        and does not require math skills beyond addition and subtraction.\n        It does require some patienceвЂ”some of the tasks might take a while to solve.\n\n        <p>The game consists of a series of levels.\n            In each level you are tasked with building a component that behaves according to a specification.\n            This component can then be used as a building-block in the next level.\n\n        <p>All components are specified through what input should lead to what output.\n        How exactly you build the component is up to you, as long as\n        input/output conforms to the specification. The game doesn't care whether or not you have found the simplest or the most efficient design.\n        It only cares if it works correctly.  \n\n        <p>The first challenge is to build an <b>inverter</b> component.\n        <p>The <b>inverter</b> has a single input and a single output, and the specification look like this:\n\n         <table class='data'>\n         <tr><th>Input</th><th>Output</th></tr>\n         <tr><td>0</td><td>1</td></tr>\n         <tr><td>1</td><td>0</td></tr>\n         </table>\n\n        <h3>The Nand gate</h3>\n\n        <p>The only component available in the first level is the <b>nand</b> gate. The nand gate is a fundamental building block which all other components can be built from.\n\n        <p>A <b>nand</b> gate has two inputs and one output, and the specification is like this:\n\n         <table class='data'>\n         <tr><th colspan=2>Input</th><th>Output</th></tr>\n         <tr><th>a</th><th>b</th><th></th></tr>\n         <tr><td>0</td><td>0</td><td>1</td></tr>\n         <tr><td>1</td><td>0</td><td>1</td></tr>\n         <tr><td>0</td><td>1</td><td>1</td></tr>\n         <tr><td>1</td><td>1</td><td>0</td></tr>\n         </table>\n\n    <p>To see the specification for a component, click its рџ›€ icon.\n\n        <h3>User guide</h3>\n\n        <p>The objective for the level is always described in the box to left of the canvas.\n        The text below the canvas (what you are reading now) contains additional information and hints.\n\n        <p>You build the circuit by dragging components\n        from the toolbox left of the canvas, and connect them by dragging the arrowheads from the output-connectors to input-connectors.\n\n    <p>You can manually test the circuit by toggling the input box at the bottom (the small checkbox).\n\n    <p>When you believe you have designed the component correctly, click \"Check solution\".\n    The system verifies if the circuit you have designed corresponds to the specification. If it does you can proceed to the next level.\n\n    <div class=subject>\n    <h3>About 0 and 1</h3>\n    <p>Input and output signals can be either 0 or 1.\n    There is no other option or middle ground. This reflects the fundamental principle of digital systems:\n    They only distinguish between two distinct states.\n    In an electrical circuit this corresponds to high and low current. But we don't care about how it works on the physical level, we just treat them as logical states.\n    </div>\n\n    <div class=subject>\n    <h3>Where does the NAND-gate come from?</h3>\n    <p>In this game we use the <b>nand</b>-gate as the most fundamental building blocks. The nand gate itself is built from transistors. A transistor is basically an electrical switch.\n    A nand gate is built from two or four transistors, depending on the type of transistors used.\n    </div>",
            "debriefing": "<b>Инвертор</b> добавлен в панель инструментов и может быть использован в дальнейшем.",
            "hints": {
                "0": "Теперь можно использовать <b>инвертор</b>!"
            }
        },
        "AND": {
            "title": "И",
            "splash": "<p>Следующие задание собрать элемент <b>И</b>, используя только ранее созданные элементы <b>И-НЕ</b> и <b>НЕ</b>.\n        (Возможно оба элемента в этом задании использовать не нужно.)",
            "specification": " <p>На выходе <b>И</b> должна быть 1, только когда оба входа также в 1:",
            "spoilers": [ "\"NAND\" расшифровывается как \"отрицающее И\"" ]
        },
        "OR": {
            "title": "ИЛИ",
            "specification": "<p>Элемент <b>ИЛИ</b> выдает 1, если хотя бы один из входов также 1:"
        },
        "XOR": {
            "title": "XOR",
            "specification": "<p><b>XOR</b> выдает 1, если сигналы на его входах отличаются:",
            "elaboration": "XOR - английское сокращение <i>исключающего ИЛИ</i>. Это можно описать как <i>либо a, либо b но не одновременно</i>."
        },
        "HALFADD": {
            "title": "Полусумматор",
            "splash": "<p>Поздравляем, вы собрали все основные логические элементы.\n        <p>Теперь нам нужна арифметика. Процессор должен уметь складывать и вычитать числа.\n\n        <p>Первая задача - сложить два однобитных числа, два бита. Результат сложения будет, очевидно, двухбитным числом.\n        <p>Для решения необходимо иметь представление о двоичной системе счисления.",
            "specification": "<p><b>add</b> складывает два бита. На выходе полусумматора получают двухразрядное число.\n        <p>Выход <b>h</b> - старший разряд/бит, <b>l</b> - младший разряд/бит.",
            "elaboration": "<div class=subject>\n\n    <h3>Двоичные числа</h3>\n\n    <p>Компьютеры выполняют арифметические операции над числами в <b>двоичной системе счисления</b>.\n\n        <p>В двоичной системе счисления, все числа представляются в виде набора 0 и 1, в отличие от обычной десятичной системы счисления\n        в которой используются цифры от 0 до 9.\n\n        <p>Например:\n\n        <table class=data>\n         <tr><th>Двоичный вид</th><th>Десятичный вид</th></tr>\n         <tr><td>00</td><td>0</td></tr>\n         <tr><td>01</td><td>1</td></tr>\n         <tr><td>10</td><td>2</td></tr>\n         <tr><td>11</td><td>3</td></tr>\n         </table>\n\n\n    Чтобы это понять, вспомним как работает десятичная система. В ней всего 10 цифр (0-9), но мы можем выражать\n и большие числа размещая их в определенном порядке. Например в трехзначном числе: самая правая цифра отвечает за единицы, центральная за десятки и левая за сотни.\n Так 273 не что иное как 2 x 100 + 7 x 10 + 3 x 1. Тоесть позиция цифры - множитель 10.\n    Поэтому это система и называется <i>десятичной</i>.\n\n<p>Двоичные числа конечно же основываются на двоичной системе счисления, поэтому используется только две цифры: 0 и 1. Соответственно позиция цифры теперь будет множителем 2: 1, 2, 4, 8, 16 и так далее.\nПоэтому 101 в двоичной, это 5 в десятичной системе (1 x 4 + 0 x 2 + 1 x 1).\nДвоичная система хорошо подходит для цифровых схем, которые как правило имеют только два состояния - 0 или 1.\n\n[TODO: Link to binary tutorial]\n\n    </div>",
            "spoilers": [ "Посмотрите на столбец каждого выхода отдельно, ничего не напоминает?" ]
        },
        "FULLADD": {
            "title": "Сумматор",
            "splash": "<p>Сейчас наш (полу)сумматор может складывать пару битов.\n        <p>Но для сложения больших чисел нужно также учитывать \"бит переноса\" от предыдущих сложений.\n        <p>Итак, задача собрать сумматор способный складывать <i>три</i> бита: a, b и c, где c - бит переноса.",
            "specification": "<p>Элемент <b>add</b> складывает 3 бита <b>a</b>, <b>b</b> и <b>c</b>.\n            <p>На выходе сумматора двухбитное число. Выход <b>h</b> - старший разряд/бит, <b>l</b> - младший разряд/бит.",
            "elaboration": "Цель состоит в том, чтобы сумматор мог складывать произвольно большие числа. Тоесть мы складываем первые две цифры числа, если есть остаток, переносим его и учитываем при сложении следующих двух цифр этого числа.\n        "
        },
        "ADD2": {
            "title": "Двухбитный сумматор",
            "splash": "<p>Теперь сделаем сумматор, который может складывать два 2-битных числа (и бит переноса).\n           <p>Таких сумматорв можно собрать несколько, чтобы увеличить разрядность (какого размера числа может складывать сумматор).",
            "specification": "<p>Соберите сумматор складывающий два 2-битных числа и бит переноса.\n    <h3>Вход</h3>\n    <p><b>a1 и a0</b> 2-битные числа.\n    <p><b>b1 и b0</b> тоже 2-битные числа.\n    <p><b>c</b> (перенос) однобитное число.\n    <h3>Выход</h3>\n    <p>Сумма  входных чисел 3-битное число <b>c s1 s0</b> где <b>c</b> старший бит.\n\n    <h3>Пример</h3>\n\n         <table class='data'>\n         <colgroup class=input><col><col></colgroup>\n         <colgroup class=input><col><col></colgroup>\n         <colgroup class=input><col></colgroup>\n         <colgroup class=output><col><col><col></colgroup>\n         <colgroup class=output><col></colgroup>\n         <tr><th colspan=5>Вход</th><th colspan=3>Выход</th></tr>\n         <tr><th>a1</th><th>a0</th><th>b1</th><th>b0</th><th>c</th><th>c</th><th>s1</th><th>s0</th></tr>\n         <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>2+2+1=5</td></tr>\n         </table>    ",
            "debriefing": "<p>Элементы, складывающие 2-битные числа, можно соединить друг с другом и получить схему складывающую огромные числа.\n\n        <p>Так как мы делаем 16-разрядный процессор, использовав несколько таких сумматоров мы получим 16-битный сумматор <b>add 16</b>."
        },
        "INC": {
            "title": "Инкремент",
            "splash": "<p>Теперь можно работать с 16-битными числами.\n\n        <p>Следующая задача собрать <b>increment</b> - элемент добавляющий 1 к 16-битному числу.\n\n        <p>Так как теперь мы работаем с 16-битными числами, можно упростить\n        схему: вместо 16  отдельных линий,\n        мы сделаем одну 16-битную шину, обозначенную как линия с цифрой \"<b>16</b>\" рядом.\n\n        ",
            "specification": "<p>Прибавьте <b>1</b> к 16 битному числу.<p>\n    <p>Остаток (бит переноса) не учитывайте.",
            "hints": {
                "0": "16-битный выход. Показывает значения на выходе в шестнадцатеричном (hex) либо в десятичном виде с учетом знака(signed decimal).",
                "1": "16-битный вход. Можно вводить число в десятичном или шестнадцатеричном виде."
            },
            "elaboration": "<p><b>Increment</b> means increasing a number by 1. This is useful in many places, for example in counters.\n\n\n        <h3>16-bit</h3>\n\n        <p>A processor always operates on multiple bits at a time.\n        The processor you are building is a <b>16-bit processor</b> which means it operates on sets of 16 bits at a time.\n\n        <p>Modern processors (such as the ones in a computer or smartphone) are typically 32-bit or 64-bit. Embedded processors such as the ones in a microwave oven might be 8-bit or 4-bit.\n        We have chosen 16 bits since this is enough to be useful.\n\n        <h3>Words and bytes</h3>\n        <p>A set of 16 bits is called a <b>word</b>. The size of a word depends on the processor.\n        A <b>byte</b> is a machine-independent unit which is always 8 bits.\n\n        <div>\n        <h3>Bus</h3>\n        <p>A set of connections treated as a unit is called a <b>bus</b>. The input and output are each a 16-bit bus.\n        The <b>A</b> and <b>B</b> inputs on the 16-bit adder are also each a 16-bit bus.\n        </div>\n\n        <div>\n        <h3>Hexadecimal</h3>\n        <p>Larger binary numbers are unwieldy to read and type for humans. Therefore we have <b>hexadecimal</b> numbers which are shorter and easier to manage.\n        Hexadecimal is a base-16 numbering system, where the letters A, B, C, D, E, F is used for the numbers ten to fifteen.\n        <p>Hexadecimal (abbreviated <i>hex</i>) is convenient for binary data since one hex digit always corresponds to four bits. A 16-bit word is four hex digits. Decimal does digits does not directly correspond to\n        binary digits, so decimal is less convenient for binary data.\n\n        <p>Examples:\n        <table class='data numbers'>\n        <tr><th>hex</th><th>unsigned decimal</th><th>binary</th></tr>\n        <tr><td>1</td><td>1</td><td>0000000000000001</td></tr>\n        <tr><td>F</td><td>15</td><td>0000000000001111</td></tr>\n        <tr><td>10</td><td>16</td><td>0000000000010000</td></tr>\n        <tr><td>2A</td><td>42</td><td>0000000000101010</td></tr>\n        <tr><td>0100</td><td>256</td><td>0000000100000000</td></tr>\n        <tr><td>FFFF</td><td>65535</td><td>1111111111111111</td></tr>\n        </table>\n\n        <p>For your convenience, the 16-bit input and output ports shows the numbers in hexadecimal alongside the binary. You can input hexadecimal numbers,\n        and they will be automatically converted to binary.\n\n        <p>A <a href=\"https://www.mathsisfun.com/hexadecimals.html\">hexadecimal tutorial</a>. [If you find a better tutorial than this one, please send me link]\n\n        </div>",
            "spoilers": [
                "Подсказка: Вход может быть ни к чему не подключен. Неподключенный вход всегда имеет значение 0. ",
                "Элемент <b>inv</b> (НЕ) не подключенный ни к чему всегда дает 1 на выходе",
                "Вход бита переноса <b>c</b> в сумматоре <b>add</b> однобитный, тоесть принимает значения 0 или 1."
            ]
        },
        "SUB": {
            "title": "Вычитание",
            "splash": "<p>Теперь сделаем элемент, который будет <b>вычитать</b> одно 16-битное число из другого.",
            "specification": "<p>На выходе 16-битное число, результат операции A минус B.\n        <p>Если результат вычитания меньше нуля, то он представляется как 65536 + результат.\n        <p>Пример:\n\n            <table class='data numbers'>\n            <tr><th>Результат</th><th>16-bit</th><th>unsgigned decimal</th></tr>\n            <tr><td>1</td><td>0000000000000001</td><td>1</td></tr>\n            <tr><td>0</td><td>0000000000000000</td><td>0</td></tr>\n            <tr><td>-1</td><td>1111111111111111</td><td>65535</td></tr>\n            <tr><td>-2</td><td>1111111111111110</td><td>65534</td></tr>\n            <tr><td>-3</td><td>1111111111111101</td><td>65533</td></tr>\n            </table>\n\n        <p>(То же самое, что дополнение числа до 2)",
            "elaboration": "<div class=subject>\n\n        <h3>Two's Complement</h3>\n        <p>Two's complement is the standard way to represent signed (positive and negative) numbers in binary.\n        <p>15й бит отвечает за знак.\n        Если 15й бит 0, число положительное; если 1, отрицательное. Отрицательные числа представляются как 65536 минус число.\n        Например -127 соотвствует число 65409, так как 65536 - 127 = 65409\n\n        <p>Примеры:\n            <table class='data numbers'>\n            <tr><th>Знаковое десят.</th><th>Беззнаковое десят.</th><th>Двоичное</th><th>Шестнадцат.</th></tr>\n            <tr><td>32767</td><td>32767</td><td>0111111111111111</td><td>7FFF</td></tr>\n            <tr><td>1</td><td>1</td><td>0000000000000001</td><td>0001</td></tr>\n            <tr><td>0</td><td>0</td><td>0000000000000000</td><td>0000</td></tr>\n            <tr><td>-1</td><td>65535</td><td>1111111111111111</td><td>FFFF</td></tr>\n            <tr><td>-2</td><td>65534</td><td>1111111111111110</td><td>FFFE</td></tr>\n            <tr><td>-3</td><td>65533</td><td>1111111111111101</td><td>FFFD</td></tr>\n            <tr><td>-32768</td><td>32768</td><td>1000000000000000</td><td>8000</td></tr>\n            </table>\n\n        <p>\n        </div>",
            "spoilers": [ "Посмотрите как побитовая отрицание (<b>inv16</b>) влияет на число", "Отрицание числа то же самое, что 65535 минус число. Отрицательное число это 65536 минус число.", "A - B = A + INV(B) + 1" ],
            "debriefing": "Поздравляем. Вы сделали все базовые элементы для выполнения арифметических операций\n                    <p>Современные процессоры поддерживают гораздо более сложные операции, такие как умножение, деление и работа с числами с плавающей точкой,\n                    но мы не будем усложнять эту игру и создадим только необходимый минимум необходимый для работы процессора."
        },
        "ISZERO": {
            "title": "Равенство 0",
            "splash": "<p>Теперь соберем элемент, который будет показывать, когда число равно 0. Для начала сделаем версию для 4-битного числа.",
            "specification": "<p>На выходе должна быть 1 только когда все биты входного числа равны 0. В любых других случаях на выходе должен быть 0",
            "debriefing": "Такой подход работает и для 16-битных чисел, поэтому мы сразу получим аналогичный элемент и для таких чисел."
        },
        "SIGN": {
            "title": "Меньше чем 0",
            "splash": "<p>Теперь спроектируйте элемент который показывает отрицательно ли число.",
            "specification": "<p>Если число на входе отрицательно, выдать 1 на выход\n\n    <p>Спецификация:\n         <table class='data'>\n         <colgroup class=input><col></colgroup>\n         <colgroup class=output><col></colgroup>\n         <tr><th>Input</th><th>Output</th></tr>\n         <tr><td>input >= 0</td><td>0</td></tr>\n         <tr><td>input < 0</td><td>1</td></tr>\n         </table>\n\n    Число считается отрицательным, если 15й бит равен 1.\n<h3>Порядок битов</h3>\nБиты пронумерованы справа налево, причем нумерация начинается с 0. Поэтому 15й бит - крайний левый бит в 16-битном слове.",
            "elaboration": "Для этого элемента мы будем представлять 16-битное число как целое со знаком, а самый левый бит как знак.\n\n        <p>Мы добавили <b>splitter</b> в набор. Сплиттер разбивает 16-битную шину на 16 отдельных соединений.\n        Используя сплиттер, можно управлять каждым из 16 битов на входе по отдельности. При этом реализация сплиттера не требуется логических элементов.\n\n        <div class=subject>\n            <h3>Signed and unsigned numbers</h3>\n\n            <p>The same 16-bit value can be interpret as either a signed or an unsigned integer. Examples for some numbers around 0:\n\n            <table class='data numbers'>\n            <tr><th>16 bit binary</th><th>Hex</th><th>Unsigned decimal</th><th>Signed decimal</th></tr>\n            <tr><td>0000000000000001</td><td>0001</td><td>1</td><td>1</td></tr>\n            <tr><td>0000000000000000</td><td>0000</td><td>0</td><td>0</td></tr>\n            <tr><td>1111111111111111</td><td>FFFF</td><td>65535</td><td>-1</td></tr>\n            <tr><td>1111111111111110</td><td>FFFE</td><td>65534</td><td>-2</td></tr>\n            <tr><td>1111111111111101</td><td>FFFD</td><td>65533</td><td>-3</td></tr>\n            </table>\n\n            <p>Conveniently, addition and subtraction work exactly the same whether we interpret the numbers as signed or unsigned.\n            This means the processor does not really need to know the difference.\n\n            [TODO: link to twos-complement tutorial]\n        </div>",
            "spoilers": [ "Вам не нужны логические элементы, только сплиттер (splitter)." ]
        },
        "MULTIPLEXER": {
            "title": "Мультиплексор",
            "specification": "<p>Мультиплексор <b>select</b> выбирает что подать на выход из двух доступных входов.\n\n    <p>Вход <b>s</b> (select) показывает мультиплексору какой их входных сигналов <b>d0</b> или <b>d1</b> подать на выход\n        Если на <b>s</b> подать 0, будет выбран вход <b>d0</b>, если 1, <b>d1</b>.",
            "elaboration": "<p>В англоязычной литературе мультиплексор часто обозначают как <b>select</b> (селектор)."
        },
        "DEMUX": {
            "title": "Дешифратор",
            "splash": "Далее соберем <b>switch</b> который подает входной сигнал на один из двух выходов.",
            "specification": "<p>Дешифратор <b>switch</b> направляет входной сигнал на один из двух выходов.\n\n    <p>Сигнал <b>s</b> (selector) определяет будет ли проходить <b>d</b> (data)\n    через <b>c1</b> или <b>c0</b>.",
            "elaboration": "<p>Обратите внимание, что дешифратор работает как мультиплексор, но наоборот</p>"
        },
        "SR_LATCH": {
            "splash": "<p>Все элементы, которые мы делали до этого, не имели память.\n\n        <p>Самое время собрать простейший триггер <b>latch</b>, элемент хранящий 1 бит информации."
        },
        "LATCH": {
            "title": "Триггер",
            "specification": "<p><b>latch</b> хранит 1 бит информации\n    <p>Когда вход <b>st</b> (store) равен 1, значение на входе <b>d</b> сохраняется и подается на выход.\n    <p>Когда же <b>st</b> равен 0, значение на входе <b>d</b> игнорируется, а на выход подается предыдущее сохраненное значение.\n\n    <p>Чтобы наглядно показать эту зависимость, введем переменную <b>out</b>, которая может хранить 1 бит:</p>\n\n         <table class='data'>\n         <colgroup class=input><col><col></colgroup>\n         <colgroup class=input><col></colgroup>\n         <colgroup class=output><col></colgroup>\n         <tr><th colspan=2>Вход</th><th>Действие</th><th>Выход</th></tr>\n         <tr><th>st</th><th>d</th><th></th><th></th></tr>\n         <tr><td>1</td><td>0</td><td>установить <b>out</b> в 0</td><td><b>out</b></td></tr>\n         <tr><td>1</td><td>1</td><td>установить <b>out</b> в 1</td><td><b>out</b></td></tr>\n         <tr><td>0</td><td>1</td><td>-</td><td><b>out</b></td></tr>\n         <tr><td>0</td><td>0</td><td>-</td><td><b>out</b></td></tr>\n         </table>"
        },
        "DFF": {
            "title": "D-триггер",
            "splash": "<p>Используя простейший триггер (latch) вы уже можете создать схему, которая может хранить информацию.\n        <p>Но тогда появляется проблема: изменения в триггерах никак не синхронизированы,\n        они происходят в непредсказуемой порядке, что может привести к состоянию гонки (race condition)\n        и вылиться в неправильный результат.\n\n        <p>Решение этой проблемы - тактовый сигнал <b>clock signal</b>, \n            который периодически изменяется и подключен ко всем синхронным элементам схемы.\n\n        <p>Синхронные элементы изменяют свое состояние только по тактовому сигналу, поэтому изменения в них происходят в одно и тоже время,\n            что позволяет избежать проблем синхронизации.\n\n        <p>В этом задании вы спроектируете <b>flip-flop</b> триггер, который хранит\n        бит информации, когда тактовый сигнал 0, но подает его на свой выход только при изменении тактового сигнала из 0 в 1.",
            "specification": "<p>D-триггер <b>DFF</b> (Data Flip-Flop) также хранит 1 бит, но изменяет значение только, когда тактовый сигнал переходит из 0 в 1.\n\n    <p>Когда <b>st</b> (store) равен 1 и сигнал <b>cl</b> (clock signal) равен 0, значение с <b>d</b> записывается.\n    Но на выходе остается старое значение.\n    <p>Когда тактовый сигнал clock переходит в 1, триггер подает на выход новое значение.\n    \n    <p>Когда сигнал <b>st</b> равен 0, <b>d</b> не производит никакого эффекта.\n    <p>Когда же <b>cl</b> 1, оба сигнала <b>st</b> и <b>d</b> игнорируются.\n\n    <p>Для описания приведем таблицу из столбцов <b>in</b> и <b>out</b>:\n\n<table class=\"data\">\n         <colgroup class=input><col><col><col></colgroup>\n         <colgroup class=input><col></colgroup>\n         <colgroup class=output><col></colgroup>\n<tr><th colspan=3>Вход</th><th>Эффект</th><th>Выход</th></tr>\n<tr><th>st</th><th>d</th><th>cl</th><th></th><th></th></tr>\n<tr><td>1</td><td>0</td><td>0</td><td>set <b>in</b> to 0</td><td><b>out</b></td></tr>\n<tr><td>1</td><td>1</td><td>0</td><td>set <b>in</b> to 1</td><td><b>out</b></td></tr>\n<tr><td>0</td><td>-</td><td>0</td><td>-</td><td><b>out</b></td></tr>\n<tr><td>-</td><td>-</td><td>1</td><td>set <b>out</b> to <b>in</b></td><td><b>out</b></td></tr>\n</table>",
            "elaboration": "<p>The clock signal is like a metronome, causing all components to change in unison.\n\n<p>A <b>clock cycle</b> is the span of the clock signal changing from 0 to 1 and then from 1 back to 0. \n\n<p>In a real processor, the clock signal is triggered by some kind of vibrating crystal. In this game, we keep the clock signal as a manual input,\nso you can manually test the circuit.\n\n<p>The <b>clock rate</b> is how fast the clock changes. The higher clock rate, the faster the computer operates.\n\n<p>Note: Despite the name, a \"clock\" does not in itself keep time. It only provide a regular beat.\nBut combined with a counter, a component which keeps track of time can be built.  \n        ",
            "spoilers": [ "Используйте два триггера-защелки.", "Записывайте в первый триггер, только когда cl=0, в другом триггере запись должна происходить с первого триггера, когда cl=1." ]
        },
        "DFF2": {
            "title": "Регистр",
            "splash": "<p>Вы уже можете сохранять 1 бит информации.\n        <p>В этом задании нужно соединить два D-триггера (DFF), чтобы хранить и читать <b>2</b> бита информации за одно действие.\n        <p>(На самом деле мы хотим сохранять 16-битные слова, однако зная как сохранять и читать 2 бита, сделать это для 16 бит проще простого.)",
            "specification": "<p>Регистр <b>2-bit DFF</b> работает почти как D-триггер,\n        только вместо одного бита, можно хранить целых два (<b>d1</b> и <b>d0</b>).",
            "elaboration": "Данный 2-битный регистр можно использовать повторно.\n           Соединив 8 таких можно получить 16-битный регистр. Элемент <b>register</b> базовый элемент памяти.",
            "debriefing": "Данная 2-битная схема легко расширяется повторением 2-битных блоков до 8, 16 или 32 бит.\n        <p>Так как мы делаем именно 16-битный компьютер, 16-битный элемент памяти (называющийся <b>register</b>) добавлен на панель инструментов слева."
        },
        "COUNTER": {
            "title": "Счетчик",
            "splash": "<p>Следующая задачa - создание счетчика, увеличивающего свое значение на 1 за каждый цикл тактового сигнала.\n        <p>Счетчик один из базовых элементов процессора, отвечающий за выборку инструкций.",
            "specification": "<p>Элемент <b>counter</b> инкрементируется каждый цикл clock'а.\n\n    <p>Выход счетчика изменяется, когда тактовый сигнал <b>cl</b> переходит из 0 в 1.\n    <p>Ксли <b>st</b> 0, тогда значение счетчика увеличивается на 1.\n    <p>Если же <b>st</b> (store) в 1, значение <b>X</b> на входе присваивается счетчику.\n\n<p>Таблица, описывающая зависимость <b>выхода</b> от <b>входа</b>:\n\n<table class=\"data\">\n         <colgroup class=input><col><col></colgroup>\n         <colgroup class=input><col></colgroup>\n         <colgroup class=output><col></colgroup>\n<tr><th colspan=2>Вход</th><th>Эффект</th><th>Выход</th></tr>\n<tr><th>st</th><th>cl</th><th></th><th></th></tr>\n<tr><td>0</td><td>0</td><td class=text>set <b>in</b> to <b>out</b> + 1</td><td><b>out</b></td></tr>\n<tr><td>1</td><td>0</td><td class=text>set <b>in</b> to <b>X</b></td><td><b>out</b></td></tr>\n<tr><td>-</td><td>1</td><td class=text>set <b>out</b> to <b>in</b></td><td><b>out</b></td></tr>\n</table>",
            "spoilers": [ "Вам понадобиться один регистр." ],
            "debriefing": ""
        },
        "RAM": {
            "title": "ОЗУ",
            "splash": "<p>Теперь вы можете сохранять 16-битные слова в регистре.\n        <p>Можно получить и больше памяти просто добавляя регистры.\n        <p>Но так как процессор работает только с одним машинным словом одновременно, нужно придумать как\n        выбирать и изменять отдельные слова в больших объемах памяти.\n        <p>Для этого существует адрес памяти.\n        <p>Каждому слову в памяти сопоставим номер\n            так мы сможем читать и перезаписывать любую запись в памяти зная ее номер.\n\n        <p>Сделайте память из 2 регистров, адресуемых одним битом (1 или 0).",
            "specification": "<p>Соберите память из двух 16-битных регистров, к которым можно было бы получить доступ, зная их номера.\n    <h3>Вход</h3>\n    <p><b>ad</b> (адрес) показывает, к какому участку памяти мы обращаемся.\n    <p><b>st</b> (хранить) показывает, хотим ли мы записать что-то в память.\n        <ul>\n        <li>Если 1, значение <b>X</b> записывается в память.\n        <li>Если 0, сигнал <b>X</b> игнорируется.\n        </ul>\n    <p><b>X</b> (данные) содержит 16-битное значение.\n    <p><b>cl</b> (тактовый сигнал) синхронизирует все изменения. <b>X</b> сохраняется, когда <b>cl</b>=0, но появляется на выходе только при переходе <b>cl</b> в 1.\n    <h3>Выход</h3>\n    <p>Значение хранится по адресу <b>ad</b>.",
            "elaboration": "<p>Память на два значения не такая и большая. Но ничто не мешает нам собрать несколько таких блоков вместе и получить память на 4, 8, 16 и т.д. значений.\n\n        <h3>Адресация</h3>\n        <p>Мы считаем ячейки памяти начиная с 0. Номер ячейки называют её <b>адресом</b>.\n        Когда мы читаем или пишем в ячейку, чтобы найти её используется адрес.\n\n        <p>Having two cells means we have only two addresses which can be selected by a single bit. Since we have a 16-bit architecture we can support up to 16-bit addresses,\n            which in turn means we can address 65,536 data words.\n\n        <p>This kind of memory is called RAM (Random Access Memory) because we can access any cell and update its value as long as we know its address.\n\n        <div class=subject>\n            <h3>Bytes and KB</h3>\n            <p>Usually memory capacity (RAM and other storage) is measured in <b>bytes</b>, where a byte is 8 bits.\n            Because we have a 16-bit architecture we store and retrieve 16-bit words at a time, each word is 2 bytes.\n            We can have 65536 memory cells (since 65535 is the highest number that can be expressed in 16 bits), so measured\n            in bytes we have twice the number, 131,072 bytes. This is usually written as 128KB (KB = kilo bytes).\n\n        <p>How does 131,072 become 128K? This is due to the wonderful fact that when measuring bytes, K does not mean 1000\n            (as with any other measurement) but 1024. And 128*1024 = 131,072.\n\n        </div>",
            "debriefing": "<p>Не составляет сложности расширить такую память до нужного размера наращивая блоки."
        },
        "ALU_PRESET": {
            "title": "Унарное АЛУ",
            "splash": "<p>Все элементы, которые мы собирали до этого выполняли только одну конкретную операцию.\n        <p>ALU (Арифметико-Логическое Устройство) - часть ядра процессора,\n           выполняющая логические и арифметические операции, такие как: сложение, вычитание, отрицание.\n        <p>Набор управляющих битов задает операцию, которую надо выполнить.\n        <p>АЛУ реализуется в 2 этапа.\n        Первый этап - \"unary ALU\" (унарное АЛУ), которое может инвертировать входной сигнал, либо выдавать 0 или 1.\n        ",
            "specification": "<p><b>Unary ALU</b> изменяет входной сигнал <b>X</b>. Два флага определяют какую операцию выполнить.\n\n<p>Если <b>z</b> (zero) в 1, тогда на выход подается 0\n<p>Если же <b>n</b> (negate) в 1, тогда входной сигнал инвертируется\n<p>Порядок флагов важен, так ,если оба флага 1, выход будет инверсией 0.\n\n<p>Спецификация:\n         <table class='data'>\n         <colgroup class=input><col><col></colgroup>\n         <colgroup class=output><col></colgroup>\n         <tr><th colspan=2>Вход</th><th>Выход</th></tr>\n         <tr><th>z</th><th>n</th><th></th><th></th></tr>\n         <tr><td>0</td><td>0</td><td>X не изменяется</td></tr>\n         <tr><td>1</td><td>0</td><td>0</td></tr>\n         <tr><td>0</td><td>1</td><td>Инверсия X</td></tr>\n         <tr><td>1</td><td>1</td><td>Инверсия 0</td></tr>\n         </table>",
            "elaboration": "<h3>Design of the Arithmetic Logical Unit (ALU)</h3>\n\n<p>The ALU is a component that can perform various different arithmetic and logical operations. \nThere are two inputs, X and Y, and a set of options (flags) that selects what operation to perform on the inputs. \n\n<p>Some of the operations it can perform are addition (X+Y), subtraction (X-Y or Y-X), logical and (X and Y), logical or (X or Y). It can also perform operations on a single input (and ignore the other); for example, increment (X+1), decrement (X-1), invert X and negate X (0-X).\n\n<p>It might look like we need a very complex component to support all these operations. But it turns out we can achieve them by combining only two operations with two possible modifications of each input and output.\n\n<p>For example, we saw in the \"subtraction\" level that subtraction can be implemented in terms of addition if we can invert one input and output.\nAnd we saw in the \"increment\" level that incrementing (adding 1 to X) can be implemented by replacing Y with 0 and then inverting and subtracting.\n<p>Just by inverting and/or zeroing any of the two inputs and perhaps the output, we can implement a whole bunch of arithmetic operations.\n\n<p>So we implement the ALU in two stages. First we build the unary component which can invert and/or zero-out an input. (\"unary\" mean it operates on a single number)\nAnd in the next stage we combine the input/output modifiers with the binary operations to complete the ALU."
        },
        "ALU": {
            "title": "АЛУ",
            "splash": "<p>Теперь мы можем сделать полноценное АЛУ.\n        <p>АЛУ принимает два 16-битных значения и 6 флагов-битов, отвечающих за тип операции.\n        ",
            "specification": "<p>ALU (Арифметико-логическое устройство) выполняет различные операции над двумя числами\n            <b>X</b> и <b>Y</b>.\n\n        <p>Шесть флагов определяют тип операции.\n            Каждый флаг вызывает операцию, если он в 1:\n\n        <ul>\n            <li><b>zx</b>: X равно 0</li>\n            <li><b>nx</b>: Инверсия X</li>\n            <li><b>zy</b>: Y равен 0</li>\n            <li><b>ny</b>: Инверсия Y</li>\n            <li><b>f</b> выбор операции на выходе:\n                    <p>0: X AND Y\n                    <br>1: X + Y\n                </li>\n            <li><b>no</b>: Инверсия</li>\n         </ul>\n\n        <p>Флаги могут быть скомбинированы, поэтому их порядок имеет значение.\n        <p>Например если <b>zx</b> и <b>nx</b> равны 1,\n        тогда X равен инверсии 0 (1).",
            "elaboration": "<p>Комбинируя всего шесть флагов, можно выполнять множество различных арифметических операций.\n        <p>Например:\n        <table class='data numbers'>\n        <tr><th>zx</th><th>nx</th><th>zy</th><th>ny</th><th>f</th><th>no</th><th>операция</th></tr>\n        <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>X + Y</td></tr>\n        <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>X - 1</td></tr>\n        <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>X and Y</td></tr>\n        <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>X - Y</td></tr>\n        <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>\n        <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>\n        </table>\n\n        <p>Возможно это несколько неочевидно, почему определенная комбинация флагов дает такой результат, но вы можете попробовать скомбинировать их сами и понять, как это работает.\n\n\n    <p>(Схема АЛУ основана на <a href=\"https://www.nand2tetris.org/\">Nand to Tetris course</a> и используется здесь с разрешения автора.)"
        },
        "CONDITION": {
            "title": "Условия",
            "splash": "",
            "specification": "<p>Три флага определяют какие из трех условий будут применены к <b>X</b>:\n\n    <table class='data text'>\n        <tr><th>Флаг</th><th>Условие</th>\n        <tr><td><b>lt</b></td><td>Меньше нуля</td>\n        <tr><td><b>eq</b></td><td>Равно нулю</td>\n        <tr><td><b>gt</b></td><td>Больше нуля</td>\n    </table>\n\n        <p>Если условия с флагом 1 выполняются, выход равен 1.\n\n\n    <p>Более того, флаги могут быть скомбинированы:\n\n         <table class='data'>\n         <tr><th colspan=3>Флаги</th> <th>Выход 1 когда</th></tr>\n         <tr><th>lt</th><th>eq</th><th>gt</th><th></th></tr>\n         <tr><td>0</td><td>0</td><td>0</td> <td>Никогда</td></tr>\n         <tr><td>0</td><td>0</td><td>1</td> <td>X &gt; 0</td></tr>\n         <tr><td>0</td><td>1</td><td>0</td> <td>X = 0</td></tr>\n         <tr><td>0</td><td>1</td><td>1</td> <td>X в‰Ґ 0</td></tr>\n         <tr><td>1</td><td>0</td><td>0</td> <td>X &lt; 0</td></tr>\n         <tr><td>1</td><td>0</td><td>1</td> <td>X в‰  0</td></tr>\n         <tr><td>1</td><td>1</td><td>0</td> <td>X в‰¤ 0</td></tr>\n         <tr><td>1</td><td>1</td><td>1</td> <td>Всегда</td></tr>\n         </table>",
            "spoilers": [ "Только одно условие может выполняться одновременно.", "Для первых двух условий уже есть готовые элементы.", "\"X в‰¤ 0\" означает, что X меньше 0 <i>или</i> равно 0.", "Выход равен 1, если <b>lt</b>=1 и X&lt;0 или <b>eq</b>=1 и X=0 или <b>gt</b>=1 и X&gt;0." ],
            "debriefing": ""
        },
        "CPU_STATE": {
            "title": "ОЗУ",
            "splash": "Процессор использует два осноных вида памяти: регистры и RAM.\n        <p>Регистры доступны процессору напрямую и используются для вычислений и хранения промежуточных значений.\n        RAM может хранить гораздо большие объемы информации, но мы можем одновременно работать только с одним адресом.\n        <p>В данном процессоре есть два регистра <b>A</b> and <b>D</b> и один блок RAM.\n        <p>Задание состоит в том, чтобы соединить регистры с RAM.\n        ",
            "specification": "<p>Память процессора состоит из двух 16-битных регистров A и D, а также блока RAM.\n\n<p>Флаги <b>a</b>, <b>d</b>, <b>*a</b> и вход <b>X</b> используются для обновления регистров.\n\n<table class='data text'>\n         <tr><th>Флаг</th><th></th></tr>\n         <tr><td>a</td><td>Записать Х в регистр А</td></tr>\n         <tr><td>d</td><td>Записать Х в регистр D</td></tr>\n         <tr><td>*a</td><tdЗаписать Х в RAM по адресу из регистра A</td></tr>\n         </table>\n\n<p>Флаги можно комбинировать так, что <b>X</b> будет одновременно записываться в несколько регистров. Если все три флага 0, значение X будет проигнорировано.\n\n<p><b>cl</b> - тактовый сигнал.\n\n         <table class='data text'>\n         <tr><th>Выход</th><th></th></tr>\n         <tr><td>A</td><td>Значение в регистре А</td></tr>\n         <tr><td>D</td><td>Значение в регистре D</td></tr>\n         <tr><td>*A</td><td>Текущее значение в RAM по адресу в регистре A </td></tr>\n         </table>",
            "elaboration": "<p>Наш процессор имеет два уровня памяти: регистры и RAM.\n        <p>RAM имеет большой объем, но для доступа к ней нужен адрес.\n        Поэтому для хранения промежуточных значений мы используем регистры: A (для адреса) и D (для данных).\n\n        <p>У реальных процессоров может быть дюжина регистров или даже больше, но наш процессор содержит минимально возможное количество - только два.\n\n        <h3>Флаги</h3>\n        <p><i>flag</i> - название входного одиночного бита, который отвечает за одну функцию. Соответственно если флагов несколько, каждый можно управлять независимо от других.\n        Например в этом задании флаги <b>a</b>, <b>d</b>, и <b>*a</b> могут быть установлены в любой комбинации."
        },
        "IO": {
            "title": "Система ввода-вывода",
            "splash": "<p>Чтобы наш компьютер можно было использовать, он должен уметь общаться с внешним миром.\n        <p>Общение происходит через такие устройства как экран, клавиатура, тачскрин, сетевой интерфейс и так далее.\n\n        <p>На этом уровне мы добавим к процессору сенсоры и моторы, чтобы получился простой робот.</p>",
            "specification": "<p>Части нашего <b>robot</b>а будут интегрированы так, \n            что мы сможем управлять ими, как обычной памятью - по адресу.\n\n            <p>Входной сигнал должен проходить, когда\n                <b>st</b> (store) в 1 и <b>cl</b> (тактовый сигнал) также в 1.\n\n            <p>Выходные сигналы должны устанавливаться сразу же</b>\n\n            <p>Соответствие входных битов <b>X</b> и управляющий сигналов:\n            <table class=data>\n            <tr><th>бит</th><th>управляющий сигнал</th></tr>\n            <tr><td>15</td><td>lo</td></tr>\n            <tr><td>14</td><td>lf</td></tr>\n            <tr><td>13</td><td>mv</td></tr>\n            <tr><td>12</td><td>stp</td></tr>\n            <tr><td>11</td><td>tl</td></tr>\n            <tr><td>10</td><td>tr</td></tr>\n            <tr><td>09</td><td>zp</td></tr>\n            </table>\n\n            <p>Mapping of device sensors to output bits:\n            <table class=data>\n            <tr><th>bit</th><th>Sensor output</th></tr>\n            <tr><td>3</td><td>mv</td></tr>\n            <tr><td>2</td><td>tn</td></tr>\n            <tr><td>1</td><td>ob</td></tr>\n            <tr><td>0</td><td>lf</td></tr>\n            </table>",
            "elaboration": "<p>Так называемый <b>memory-mapped</b> вход или выход означает, что внешние устройства\n               интегрированы в адресное пространство памяти, как будто это обычные блоки RAM.\n\n            <p>Это значит, что процессор может обращаться к таким устройствам так же, как к памяти.\n\n            <p>"
        }
    }
}
